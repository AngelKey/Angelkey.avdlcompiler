// Generated by IcedCoffeeScript 108.0.11
(function() {
  var BaseEmitter, PythonEmitter, path_lib, pkg, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  path_lib = require('path');

  BaseEmitter = require('./base_emitter').BaseEmitter;

  pkg = require('../package.json');

  _ = require('lodash');

  exports.PythonEmitter = PythonEmitter = (function(_super) {
    __extends(PythonEmitter, _super);

    function PythonEmitter() {
      PythonEmitter.__super__.constructor.apply(this, arguments);
      this._tab_char = " ".repeat(4);
    }

    PythonEmitter.prototype.emit_primitive_type = function(m) {
      var map;
      map = {
        string: "str"
      };
      return map[m] || m;
    };

    PythonEmitter.prototype.emit_field_type = function(t, _arg) {
      var optional, optionalkey, pointed, type, _ref;
      _ref = _arg != null ? _arg : {}, pointed = _ref.pointed, optionalkey = _ref.optionalkey;
      optional = !!pointed || optionalkey;
      type = typeof t === 'string' ? this.emit_primitive_type(t) : typeof t === 'object' ? Array.isArray(t) ? t[0] == null ? (optional = true, "*" + this.emit_field_type(t[1]).type) : "ERROR" : t.type === "array" ? "[]" + this.emit_field_type(t.items).type : t.type === "map" ? this.make_map_type({
        t: t
      }) : "ERROR" : "ERROR";
      if (pointed) {
        type = "*" + type;
      }
      return {
        type: type,
        optional: optional
      };
    };

    PythonEmitter.prototype.emit_preface = function(infiles, _arg) {
      var infile, namespace, _i, _len;
      namespace = _arg.namespace;
      this.output('"""' + namespace);
      this.output("");
      this.output("Auto-generated to Python types by " + pkg.name + " v" + pkg.version + " (" + pkg.homepage + ")");
      this.output("Input files:");
      for (_i = 0, _len = infiles.length; _i < _len; _i++) {
        infile = infiles[_i];
        this.output(" - " + (path_lib.relative(process.cwd(), infile)));
      }
      this.output('"""');
      return this.output("");
    };

    PythonEmitter.prototype.emit_imports = function(_arg, outfile) {
      var import_as, imports, path, _i, _len, _ref;
      imports = _arg.imports;
      imports = _.uniqWith(imports, _.isEqual);
      for (_i = 0, _len = imports.length; _i < _len; _i++) {
        _ref = imports[_i], import_as = _ref.import_as, path = _ref.path;
        if (!(path.indexOf('/') >= 0)) {
          continue;
        }
        if (!import_as) {
          continue;
        }
        path = path.replace('/', '.');
        path = path.slice(1);
        this.output("from " + path + " import * as " + import_as);
      }
      return this.output("");
    };

    PythonEmitter.prototype.emit_typedef = function(t) {
      return this.output("" + t.name + " = " + (this.emit_field_type(t.typedef).type));
    };

    PythonEmitter.prototype.emit_fixed = function(t) {
      return this.output("" + t.name + " = Optional[str]");
    };

    PythonEmitter.prototype.emit_enum = function(t) {
      var e_name, e_num, s, _i, _j, _len, _ref, _ref1;
      this.output("class " + t.name + "(Enum):");
      this.tab();
      _ref = t.symbols;
      for (_ = _i = 0, _len = _ref.length; _i < _len; _ = ++_i) {
        s = _ref[_];
        _ref1 = s.split("_"), e_name = 2 <= _ref1.length ? __slice.call(_ref1, 0, _j = _ref1.length - 1) : (_j = 0, []), e_num = _ref1[_j++];
        e_name = e_name.join("_");
        this.output("" + e_name + " = " + e_num);
      }
      this.untab();
      return this.output("");
    };

    return PythonEmitter;

  })(BaseEmitter);

}).call(this);
