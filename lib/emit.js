// Generated by IcedCoffeeScript 108.0.9
(function() {
  var GoEmitter, fs, is_one_way, make_esc, minimist, pkg;

  minimist = require('minimist');

  fs = require('fs');

  make_esc = require('iced-error').make_esc;

  pkg = require('../package.json');

  is_one_way = function(d) {
    return (d.notify != null) || d.oneway;
  };

  exports.GoEmitter = GoEmitter = (function() {
    function GoEmitter() {
      this._code = [];
      this._tabs = 0;
      this._pkg = null;
    }

    GoEmitter.prototype.go_export_case = function(n) {
      var ret;
      ret = n[0].toUpperCase() + n.slice(1);
      return this.go_lint_capitalize(ret);
    };

    GoEmitter.prototype.go_lint_capitalize = function(n) {
      n = n.replace(/pgp/g, "PGP");
      n = n.replace(/Pgp/g, "PGP");
      return n;
    };

    GoEmitter.prototype.go_package = function(n) {
      return n.replace(/[.-]/g, "");
    };

    GoEmitter.prototype.go_primitive_type = function(m) {
      var map;
      map = {
        boolean: "bool",
        bytes: "[]byte",
        long: "int64",
        float: "float32",
        double: "float64"
      };
      return map[m] || m;
    };

    GoEmitter.prototype.tabs = function() {
      var i;
      return ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this._tabs; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push("\t");
        }
        return _results;
      }).call(this)).join("");
    };

    GoEmitter.prototype.output = function(l) {
      this._code.push(this.tabs() + l);
      if ((l === "}" || l === ")") && this._tabs === 0) {
        return this._code.push("");
      }
    };

    GoEmitter.prototype.tab = function() {
      return this._tabs++;
    };

    GoEmitter.prototype.untab = function() {
      return this._tabs--;
    };

    GoEmitter.prototype.emit_field_type = function(t) {
      var optional, type;
      optional = false;
      type = typeof t === 'string' ? this.go_primitive_type(t) : typeof t === 'object' ? Array.isArray(t) && (t[0] == null) ? (optional = true, "*" + this.go_primitive_type(t[1])) : t.type === "array" ? "[]" + this.go_primitive_type(t.items) : t.type === "map" ? "map[string]" + this.go_primitive_type(t.values) : "ERROR" : "ERROR";
      return {
        type: type,
        optional: optional
      };
    };

    GoEmitter.prototype.emit_typedef = function(t) {
      this.output("type " + t.name + " " + (this.emit_field_type(t.typedef).type));
      return true;
    };

    GoEmitter.prototype.emit_record = function(json, _arg) {
      var f, omitempty, optional, type, wrapper, _i, _len, _ref, _ref1;
      wrapper = _arg.wrapper;
      this.output("type " + (this.go_export_case(json.name)) + " struct {");
      this.tab();
      if (wrapper) {
        this.emit_wrapper_record_first();
      }
      _ref = json.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        _ref1 = this.emit_field_type(f.type), type = _ref1.type, optional = _ref1.optional;
        omitempty = optional ? ",omitempty" : "";
        this.output([this.go_export_case(f.name), this.go_lint_capitalize(type), "`codec:\"" + f.name + omitempty + "\" json:\"" + f.name + omitempty + "\"`"].join("\t"));
      }
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_fixed = function(t) {
      return this.output("type " + t.name + " [" + t.size + "]byte");
    };

    GoEmitter.prototype.emit_types = function(_arg) {
      var t, types, _i, _len, _results;
      types = _arg.types;
      _results = [];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        t = types[_i];
        _results.push(this.emit_type(t));
      }
      return _results;
    };

    GoEmitter.prototype.emit_type = function(t) {
      switch (t.type) {
        case "record":
          if (t.typedef) {
            return this.emit_typedef(t);
          } else {
            return this.emit_record(t, {});
          }
          break;
        case "fixed":
          return this.emit_fixed(t);
        case "enum":
          return this.emit_enum(t);
      }
    };

    GoEmitter.prototype.emit_enum = function(t) {
      var i, s, _i, _len, _ref;
      this.output("type " + t.name + " int");
      this.output("const (");
      this.tab();
      _ref = t.symbols;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        s = _ref[i];
        i = s.split("_").pop(-1);
        s = s.replace("_" + i, "");
        this.output("" + t.name + "_" + s + " " + t.name + " = " + i);
      }
      this.untab();
      return this.output(")");
    };

    GoEmitter.prototype.emit_wrapper_objects = function(messages) {
      var k, v, _results;
      _results = [];
      for (k in messages) {
        v = messages[k];
        _results.push(this.emit_wrapper_object(k, v));
      }
      return _results;
    };

    GoEmitter.prototype.emit_wrapper_object = function(name, details) {
      var args, klass_name, obj;
      args = details.request;
      klass_name = this.go_export_case(name) + "Arg";
      obj = {
        name: klass_name,
        fields: args
      };
      this.emit_record(obj, {});
      return details.request = {
        type: klass_name,
        name: "__arg",
        wrapper: true,
        nargs: args.length,
        single: args.length === 1 ? args[0] : null
      };
    };

    GoEmitter.prototype.emit_interface = function(_arg) {
      var messages, protocol;
      protocol = _arg.protocol, messages = _arg.messages;
      this.emit_wrapper_objects(messages);
      this.emit_interface_server(protocol, messages);
      return this.emit_interface_client(protocol, messages);
    };

    GoEmitter.prototype.emit_interface_client = function(protocol, messages) {
      var k, p, v, _results;
      p = this.go_export_case(protocol);
      this.output("type " + p + "Client struct {");
      this.tab();
      this.output("Cli rpc.GenericClient");
      this.untab();
      this.output("}");
      _results = [];
      for (k in messages) {
        v = messages[k];
        _results.push(this.emit_message_client(protocol, k, v, false));
      }
      return _results;
    };

    GoEmitter.prototype.emit_package = function(_arg) {
      var namespace;
      namespace = _arg.namespace;
      this.output("package " + (this.go_package(namespace)));
      this.output("");
      return this._pkg = namespace;
    };

    GoEmitter.prototype.emit_imports = function(_arg) {
      var import_as, imports, line, messages, path, _i, _len, _ref;
      imports = _arg.imports, messages = _arg.messages;
      this.output("import (");
      this.tab();
      this.output('rpc "github.com/keybase/go-framed-msgpack-rpc"');
      if (Object.keys(messages).length > 0) {
        this.output('context "golang.org/x/net/context"');
      }
      for (_i = 0, _len = imports.length; _i < _len; _i++) {
        _ref = imports[_i], import_as = _ref.import_as, path = _ref.path;
        if (!(path.indexOf('/') >= 0)) {
          continue;
        }
        line = "";
        if (import_as != null) {
          line = import_as + " ";
        }
        line += '"' + path + '"';
        this.output(line);
      }
      this.untab();
      this.output(")");
      return this.output("");
    };

    GoEmitter.prototype.emit_interface_server = function(protocol, messages) {
      var k, p, v;
      p = this.go_export_case(protocol);
      this.output("type " + p + "Interface interface {");
      this.tab();
      for (k in messages) {
        v = messages[k];
        this.emit_message_server(k, v);
      }
      this.untab();
      this.output("}");
      return this.emit_protocol_server(protocol, messages);
    };

    GoEmitter.prototype.emit_server_hook = function(name, details) {
      var arg, res, resvar;
      arg = details.request;
      res = details.response;
      resvar = res != null ? "ret, " : "";
      this.output("\"" + name + "\": {");
      this.tab();
      this.emit_server_hook_make_arg(name, details);
      this.emit_server_hook_make_handler(name, details);
      this.emit_server_hook_method_type(name, details);
      this.untab();
      return this.output("},");
    };

    GoEmitter.prototype.emit_server_hook_make_arg = function(name, details) {
      var arg;
      arg = details.request;
      this.output("MakeArg: func() interface{} {");
      this.tab();
      this.output("ret := make([]" + (this.go_primitive_type(arg.type)) + ", 1)");
      this.output("return &ret");
      this.untab();
      return this.output("},");
    };

    GoEmitter.prototype.emit_server_hook_method_type = function(name, details) {
      return this.output("MethodType: rpc.Method" + (is_one_way(details) ? 'Notify' : 'Call') + ",");
    };

    GoEmitter.prototype.emit_server_hook_make_handler = function(name, details) {
      var access, arg, farg, pt, res, resvar;
      arg = details.request;
      res = details.response;
      resvar = res != null ? "ret, " : "";
      pt = this.go_primitive_type(arg.type);
      this.output("Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {");
      this.tab();
      if (arg.nargs > 0) {
        this.output("typedArgs, ok := args.(*[]" + pt + ")");
        this.output("if !ok {");
        this.tab();
        this.output("err = rpc.NewTypeError((*[]" + pt + ")(nil), args)");
        this.output("return");
        this.untab();
        this.output("}");
      }
      farg = arg.nargs === 0 ? '' : (access = arg.nargs === 1 ? "." + (this.go_export_case(arg.single.name)) : '', "(*typedArgs)[0]" + access);
      this.output("" + resvar + "err = i." + (this.go_export_case(name)) + "(ctx, " + farg + ")");
      this.output("return");
      this.untab();
      return this.output("},");
    };

    GoEmitter.prototype.emit_protocol_server = function(protocol, messages) {
      var k, p, v;
      p = this.go_export_case(protocol);
      this.output("func " + p + "Protocol(i " + p + "Interface) rpc.Protocol {");
      this.tab();
      this.output("return rpc.Protocol {");
      this.tab();
      this.output("Name: \"" + this._pkg + "." + protocol + "\",");
      this.output("Methods: map[string]rpc.ServeHandlerDescription{");
      this.tab();
      for (k in messages) {
        v = messages[k];
        this.emit_server_hook(k, v);
      }
      this.untab();
      this.output("},");
      this.untab();
      this.output("}");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_message_server = function(name, details) {
      var arg, args, res, res_types;
      arg = details.request;
      res = details.response;
      args = arg.nargs ? "" + (this.emit_field_type((arg.single || arg).type)).type : "";
      res_types = [];
      if (res != null) {
        res_types.push(this.go_lint_capitalize(this.emit_field_type(res).type));
      }
      res_types.push("error");
      return this.output("" + (this.go_export_case(name)) + "(context.Context, " + args + ") (" + (res_types.join(",")) + ")");
    };

    GoEmitter.prototype.emit_message_client = function(protocol, name, details, async) {
      var arg, n, oarg, out_list, outs, ow, p, params, parg, res, res_in;
      p = this.go_export_case(protocol);
      arg = details.request;
      res = details.response;
      out_list = [];
      if (res != null) {
        out_list.push("res " + (this.go_lint_capitalize(this.emit_field_type(res).type)));
        res_in = "&res";
      } else {
        res_in = "nil";
      }
      out_list.push("err error");
      outs = out_list.join(",");
      params = arg.nargs === 0 ? "" : (parg = arg.single || arg, "" + parg.name + " " + (this.emit_field_type(parg.type)).type);
      this.output("func (c " + p + "Client) " + (this.go_export_case(name)) + "(ctx context.Context, " + params + ") (" + outs + ") {");
      this.tab();
      if (arg.nargs === 1) {
        n = arg.single.name;
        this.output("" + arg.name + " := " + arg.type + "{ " + (this.go_export_case(n)) + " : " + n + " }");
      }
      oarg = "[]interface{}{";
      oarg += arg.nargs === 0 ? "" + arg.type + "{}" : arg.name;
      oarg += "}";
      ow = is_one_way(details);
      res = ow ? "" : ", " + res_in;
      this.output("err = c.Cli." + (ow ? "Notify" : "Call") + "(ctx, \"" + this._pkg + "." + protocol + "." + name + "\", " + oarg + res + ")");
      this.output("return");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_preface = function(_arg) {
      var infile;
      infile = _arg.infile;
      this.output("// Auto-generated by " + pkg.name + " v" + pkg.version + " (" + pkg.homepage + ")");
      this.output("//   Input file: " + infile);
      return this.output("");
    };

    GoEmitter.prototype.run = function(_arg) {
      var infile, json;
      infile = _arg.infile, json = _arg.json;
      this.emit_preface({
        infile: infile
      });
      this.emit_package(json);
      this.emit_imports(json);
      this.emit_types(json);
      this.emit_interface(json);
      return this._code;
    };

    return GoEmitter;

  })();

}).call(this);
